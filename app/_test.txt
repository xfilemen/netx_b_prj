import prisma from '/lib/prisma';
import bcryptObj from "/lib/bcrypt";
import jwt from 'jsonwebtoken';
import { cookies } from 'next/headers';

const JWT_KEY = process.env.JWT_KEY || '';

export async function POST(req,res) {
  const data = await req.json();
  const { cj_id, password } = data;
  console.log(cj_id, password );

  const getUser = await prisma.user.findMany({
    where: {
      cj_id: cj_id 
    }
  })

  console.log(getUser)

  if(getUser.length == 0){
    return new Response(JSON.stringify({ message: '존재하지 않는 계정' }), {
      status: 401,
    })

  } else if (!bcryptObj.compare(password,getUser[0].password)) {
    return new Response(JSON.stringify({ message: '패스워드 불일치' }), {
      status: 401,
    })
  }


  // JWT 토큰 생성
  const token = jwt.sign(
    { id: getUser[0].cj_id, email: getUser[0].email }, // 페이로드에 사용자 ID와 이메일 포함
     JWT_KEY, // 비밀 키
    { expiresIn: '1h' } // 토큰 만료 시간 설정
  );
  try {
    console.log(token);
    console.log(typeof token);
    jwt.verify(token, JWT_KEY);
    console.log('토큰 일치');
  } catch (error) {
    console.log('토큰 불일치');
  }


  cookies().set({
    name: 'accessToken',
    value: token,
    httpOnly: true,
    maxAge: 60 * 60, // 1시간
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    path: '/',
  })

  // res.headers.set('Set-Cookie', cookie.serialize('accessToken', token, {
  //   httpOnly: true,
  //   secure: process.env.NODE_ENV === 'production',
  //   maxAge: 60 * 60, // 1시간
  //   sameSite: 'lax',
  //   path: '/',
  // }));




  return new Response(JSON.stringify({ message: '로그인 성공',token }), {
    status: 200,
  })   


}




import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import jwt from 'jsonwebtoken';
import { cookies } from 'next/headers';

const JWT_KEY = process.env.JWT_KEY || '';

export function middleware(request: NextRequest) {
  const token = cookies().get('accessToken') ||''; // 쿠키에서 인증 토큰 확인

  // 인증이 필요한 페이지 경로
  const protectedPages = ['/notice', '/file'];

  const replaceTerms = ["/board", "/write", "/list"];

  // 정규식 생성  
  const regex = new RegExp(replaceTerms.join("|"), "gi"); 

  const board_id = (request.nextUrl.pathname).replace(regex,'');


  console.log('Request URL:', request.nextUrl.pathname);  // 요청 URL 출력
  console.log('board id:', board_id);  // 요청 URL 출력
  console.log('Token:', token);  // 토큰 값 출력
  console.log('Auth Token:', token['value']);  // 토큰 값 출력
  console.log('JWT_KEY:', JWT_KEY);  // 토큰 값 출력

  try {
    //jwt.verify(token, JWT_KEY);
    jwt.verify( token['value'], JWT_KEY); // 토큰 검증
    console.log(111111);
  } catch (error) {
    return NextResponse.json({ message: error }, { status: 401 });
  }


  /*
  if (!protectedPages.includes(board_id)) {
      return new NextResponse(null, { status: 404 }); // 404 상태 코드 반환
  }
  */


  return NextResponse.next(); // 요청을 그대로 통과시킴
}

// 미들웨어를 적용할 경로 설정
export const config = {
  matcher: ['/detail/:path*', '/detail/:path*'], // 특정 경로에만 미들웨어 적용
};